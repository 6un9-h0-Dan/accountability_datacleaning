---
title: "Deleware Expenditures"
author: "Kiernan Nicholls"
date: "`r Sys.time()`"
output:
  github_document: 
    df_print: tibble
    toc: true
    toc_dept: 2
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, purl=FALSE}
library(knitr)
opts_chunk$set(
  eval = TRUE,
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  comment = "#>",
  fig.path = "../plots/",
  fig.width = 10,
  dpi = 300
)
options(width = 99)
set.seed(10753)
```

## Project

The Accountability Project is an effort to cut across data silos and give journalists, policy
professionals, activists, and the public at large a simple way to search across huge volumes of
public data about people and organizations.

Our goal is to standardizing public data on a few key fields by thinking of each dataset row as a
transaction. For each transaction there should be (at least) 3 variables:

1. All **parties** to a transaction
2. The **date** of the transaction
3. The **amount** of money involved

## Objectives

This document describes the process used to complete the following objectives:

1. How many records are in the database?
1. Check for duplicates
1. Check ranges
1. Is there anything blank or missing?
1. Check for consistency issues
1. Create a five-digit ZIP Code called `ZIP5`
1. Create a `YEAR` field from the transaction date
1. Make sure there is data on both parties to a transaction

## Packages

The following packages are needed to collect, manipulate, visualize, analyze, and communicate
these results. The `pacman` package will facilitate their installation and attachment.

The IRW's `campfin` package will also have to be installed from GitHub. This package contains
functions custom made to help facilitate the processing of campaign finance data.

```{r load_packages, message=FALSE, dfrning=FALSE, error=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load_current_gh("kiernann/campfin")
pacman::p_load(
  stringdist, # levenshtein value
  tidyverse, # data manipulation
  RSelenium, # remote browser
  lubridate, # datetime strings
  magrittr, # pipe opperators
  tidytext, # text analysis
  janitor, # dataframe clean
  batman, # parse logical
  refinr, # cluster and merge
  scales, # format strings
  rvest, # read html files
  knitr, # knit documents
  vroom, # read files fast
  glue, # combine strings
  here, # relative storage
  fs # search storage 
)
```

This document should be run as part of the `R_campfin` project, which lives as a sub-directory of
the more general, language-agnostic [`irworkshop/accountability_datacleaning`][01] GitHub
repository.

The `R_campfin` project uses the [RStudio projects][02] feature and should be run as such. The
project also uses the dynamic `here::here()` tool for file paths relative to _your_ machine.

```{r where_here, collapse=TRUE}
# where does this document knit?
here::here()
```

## Data

This data is obtained from the Delaware [Campaign Finance Reporting System (CFRS)][03].

On the [Expenditures search page][04], the CFRS describes the data that can be searched.

> An expenditure is defined as a gift, transfer, disbursement, debt incurred, or promise of money
or valuable thing by or on behalf of a political committee to promote or assist in promoting the
success or defeat of a candidate, political party, or question at  an election. Expenditures must
be election related; that is, they must enhance the candidate's election chances, such that they
would not have been incurred if there had been no candidacy. Furthermore, expenditures, including
loans, may not be for the personal use of the candidate or any other individual. Debt Incurred is
any unpaid debt that the committee is obligated to pay.

On the [their FAQ page][05], the CFRS defines exactly what expenditures are reported.

>  All receipts over $100 must be itemized and all sales items over $50 must be itemized. All
contributions from a political committee shall be itemized no matter what amount. If the person who
made the contribution is an organization, and the total amount of contributions by such
organization during the election period exceeds $1,200, then the report shall also include the name
and address of one responsible party for the organization.

[03]: https://cfrs.elections.delaware.gov/
[04]: https://cfrs.elections.delaware.gov/Public/ViewExpensesMain
[05]: https://cfrs.elections.delaware.gov/Public/FAQ

### Download

```{r raw_dir}
raw_dir <- here("de", "expends", "data", "raw")
dir_create(raw_dir)
```

The data can only be downloaded through the CFRS search portal. We can use the RSelenium package
to programatically navigate to the page, fill out the form, and download the results to the `/raw`
directory.

```{r download_raw, warning=FALSE, error=FALSE, message=FALSE, collapse=TRUE, eval=FALSE}
# open the driver with auto download options
remote_driver <- rsDriver(
  port = 4444L,
  browser = "firefox",
  extraCapabilities = makeFirefoxProfile(
    list(
      browser.download.dir = raw_dir,
      browser.download.folderList = 2L,
      browser.helperApps.neverAsk.saveToDisk = "text/csv"
    )
  )
)
# navigate to the download site
remote_browser <- remote_driver$client
remote_browser$navigate("https://cfrs.elections.delaware.gov/Public/ViewExpenses")
# enter Jan 1 2008 as start date
remote_browser$findElement("css", "#dtStartDate")$sendKeysToElement(list("01/01/2008"))
# enter today as end date
remote_browser$findElement("css", "#dtEndDate")$sendKeysToElement(list(format(today(),"%m/%d/%Y")))
# click the submit button
remote_browser$findElement("css", "#btnSearch")$clickElement()
# click CSV export
remote_browser$findElement("css", "a.t-button:nth-child(1)")$clickElement()
# close the browser and driver
remote_browser$close()
remote_driver$server$stop()
```

### Read

The file can then me read into R using `readr::read_csv()`

```{r read_raw}
de <- read_csv(
  file = glue("{raw_dir}/Expensesinfo.csv"),
  col_types = cols(
    .default = col_character(),
    `Expenditure Date` = col_date("%m/%d/%Y"),
    `Amount($)` = col_double()
  )
)
```

The file does not use quotation marks to distinguish character strings, causing R to erroneously
shift columsn when one is unexpectedly present.

```{r problems_raw}
problems(de) %>% 
  select(col, expected, actual) %>%
  filter(!is.na(col)) %>% 
  distinct()
```

We can improve the usability and uniformity of the data set before exploration.

```{r clean_raw}
de <- de %>% 
  clean_names() %>% 
  remove_empty("cols") %>% 
  mutate_if(is_character, str_to_upper) %>% 
  mutate(fixed_asset = to_logical(fixed_asset))
```

```{r read_mess}
# this is an absolute mess
de <- 
  read_lines(file = glue("{raw_dir}/Expensesinfo.csv")) %>% 
  str_split(",") %>%
  map(str_c, collapse = "\v") %>% 
  str_remove_all("\\\"") %>% 
  enframe(
    name = NULL,
    value = "line"
  ) %>% 
  mutate(delim_count = str_count(line, "\v")) %>% 
  mutate(
    new = if_else(
      condition = equals(delim_count, 2),
      true = str_c(line, lead(line), sep = "\v"),
      false = line
    )
  ) %>% 
  mutate(delim_recount = str_count(new, "\v")) %>% 
  filter(delim_recount == 16) %>%
  pull(new) %>% 
  str_c(collapse = "\n") %>% 
  read_delim(
    delim = "\v",
    col_types = cols(
      .default = col_character(),
      `Expenditure Date` = col_date("%m/%d/%Y"),
      `Amount($)` = col_double()
    )
  ) %>% 
  clean_names() %>% 
  remove_empty("cols") %>% 
  mutate_if(is_character, str_to_upper) %>% 
  mutate(fixed_asset = to_logical(fixed_asset))
```

## Explore

```{r glimpse}
head(de)
tail(de)
glimpse(sample_frac(de))
```

### Missing

```{r glimpse_na}
glimpse_fun(de, count_na)
```

Any record missing one of the parties, an amount, or date will be flagged with `na_flag`.

```{r flag_na, collapse=TRUE}
de <- de %>% 
  mutate(
    na_flag = is.na(committee_name) | is.na(payee_name) | is.na(amount) | is.na(expenditure_date)
  )

sum(de$na_flag)
```

### Duplicates

Any duplicate rows (after the inital appearance) can be flagged with `campfin::flag_dupes()`.

```{r get_dupes}
de <- flag_dupes(de)
sum(de$dupe_flag)
```

### Categorical

```{r glimpse_distinct}
glimpse_fun(de, n_distinct)
```

```{r payee_type_bar, echo=FALSE}
explore_plot(
  data = de,
  var = payee_type,
  nbar = 8,
  flip = TRUE,
  title = "Deleware Expenditure Payee Type",
  caption = "Source: DE CFRS"
)
```

```{r exp_cat_bar, echo=FALSE}
explore_plot(
  data = de,
  var = expense_category,
  nbar = 8,
  flip = TRUE,
  title = "Deleware Expenditure Category",
  caption = "Source: DE CFRS"
)
```

```{r exp_method_bar, echo=FALSE}
explore_plot(
  data = drop_na(de, expense_method),
  var = expense_method,
  nbar = 8,
  flip = TRUE,
  title = "Deleware Expenditure Method",
  caption = "Source: DE CFRS"
)
```

### Continuous

#### Amounts

```{r summary_amount}
summary(de$amount)
sum(de$amount < 0)
```

```{r amount_histogram, echo=FALSE}
de %>%
  ggplot(aes(amount)) +
  geom_histogram() +
  scale_x_continuous(
    labels = dollar,
    trans = "log10"
  ) +
  labs(
    title = "Deleware Expenditure Method",
    caption = "Source: DE CFRS",
    x = "Amount",
    y = "Count"
  )
```

```{r amount_box_method, echo=FALSE}
de %>% 
  filter(
    expense_method %in% c(
        "CHECK", 
        "DEBIT CARD",
        "CREDIT CARD", 
        "ELECTRONIC FUND TRANSFER", 
        "CASH"
      )
  ) %>% 
  ggplot(
    mapping = aes(
      x = reorder(
        x = expense_method, 
        X = amount, 
        FUN = median, 
        na.rm = TRUE
      ), 
      y = amount
    )
  ) +
  geom_boxplot(
    varwidth = TRUE,
    outlier.alpha = 0.01,
    mapping = aes(fill = expense_method)
  ) +
  scale_y_continuous(
    breaks = c(1 %o% 10^(0:6)),
    trans = "log10",
    labels = dollar
  ) +
  scale_fill_brewer(
    guide = FALSE,
    type = "qual",
    palette = "Dark2"
  ) +
  labs(
    title = "Deleware Expenditure Method",
    caption = "Source: DE CFRS",
    x = "Expense Method",
    y = "Amount"
  )
```

#### Dates

The range of `expenditure_date` is very good, there are `r sum(de$expenditure_date > today())` 
dates beyond `today()`.

```{r date_range}
min(de$expenditure_date)
max(de$expenditure_date)
sum(de$expenditure_date > today())
```

We can use `lubridate::year()` to create a `expenditure_year()` variable.

```{r add_year}
de <- mutate(de, expenditure_year = year(expenditure_date))
```


```{r year_bar, echo=FALSE}
de %>% 
  count(expenditure_year, sort = T) %>% 
  mutate(
    on = is_even(expenditure_year),
    p = n/sum(n)
  ) %>%
  ggplot(aes(x = expenditure_year, y = p)) +
  geom_col(aes(fill = on)) +
  scale_y_continuous(labels = percent) +
  scale_x_continuous(breaks = 2008:2019) +
  scale_fill_brewer(
    type = "qual",
    palette = "Dark2"
  ) +
  labs(
    title = "Deleware Expenditure Year Count",
    caption = "Source: DE CFRS",
    fill = "Election Year",
    x = "Year",
    y = "Percent"
  ) +
  theme(legend.position = "bottom")
```

```{r month_amount_line, echo=FALSE}
de %>%
  mutate(
    month = month(expenditure_date),
    on = is_even(expenditure_year),
  ) %>%
  group_by(month, on) %>%
  summarize(mean = mean(amount)) %>% 
  ggplot(aes(x = month, y = mean)) +
  geom_line(aes(color = on), size = 2) +
  scale_y_continuous(labels = dollar) +
  scale_x_continuous(labels = month.abb, breaks = 1:12) +
  scale_color_brewer(
    type = "qual",
    palette = "Dark2"
  ) +
  labs(
    title = "Deleware Expenditure Amount by Month",
    caption = "Source: DE CFRS",
    fill = "Election Year",
    x = "Month",
    y = "Mean Amount"
  ) +
  theme(legend.position = "bottom")
```

## Wrangle

### Address

```{r normal_address}
de <- de %>% 
  unite(
    col = payee_address_combine,
    starts_with("payee_address"),
    sep = " ",
    remove = FALSE,
    na.rm = TRUE
  ) %>% 
  mutate(
    address_norm = normal_address(
      address = payee_address_combine,
      add_abbs = usps,
      na_rep = TRUE
    )
  )
```

```{r}
sample_frac(de) %>% 
  select(payee_address_line_1, payee_address_line_2, address_norm)
```

### ZIP

```{r count_zip_pre, collapse=TRUE}
n_distinct(de$payee_zip)
prop_in(de$payee_zip, geo$zip, na.rm = TRUE)
length(setdiff(de$payee_zip, geo$zip))
```

```{r normal_zip}
de <- de %>% 
  mutate(
    zip_norm = normal_zip(
      zip = payee_zip,
      na_rep = TRUE
    )
  )
```

```{r count_zip_post, collapse=TRUE}
n_distinct(de$zip_norm)
prop_in(de$zip_norm, geo$zip, na.rm = TRUE)
length(setdiff(de$zip_norm, geo$zip))
```

### State

The `payee_state` variable does not need to be cleaned.

```{r count_state_pre, collapse=TRUE}
n_distinct(de$payee_state)
prop_in(de$payee_state, geo$state, na.rm = TRUE)
length(setdiff(de$payee_state, geo$state))
```

### City

```{r count_city_pre, collapse=TRUE}
n_distinct(de$payee_city)
prop_in(de$payee_city, geo$city, na.rm = TRUE)
length(setdiff(de$payee_city, geo$city))
```

#### Normalize

```{r normal_city}
de <- de %>% 
  mutate(
    city_norm = normal_city(
      city = payee_city, 
      geo_abbs = usps_city,
      st_abbs = c("DE", "DC", "DELEWARE"),
      na = na_city,
      na_rep = TRUE
    )
  )
```

```{r count_city_post_norm, collapse=TRUE}
n_distinct(de$city_norm)
prop_in(de$city_norm, geo$city, na.rm = TRUE)
length(setdiff(de$city_norm, geo$city))
```

#### Swap

```{r swap_city}
de <- de %>% 
  left_join(
    y = geo,
    by = c(
      "payee_state" = "state",
      "zip_norm" = "zip"
    )
  ) %>% 
  rename(city_match = city) %>% 
  mutate(
    match_dist = stringdist(city_norm, city_match),
    city_swap = if_else(
      condition = equals(match_dist, 1),
      true = city_match,
      false = city_norm
    )
  )
```

```{r count_city_post_swap, collapse=TRUE}
n_distinct(de$city_swap)
prop_in(de$city_swap, geo$city, na.rm = TRUE)
length(setdiff(de$city_swap, geo$city))
```

```{r city_progress, echo=FALSE}
tibble(
  step = c("raw", "norm", "swap"),
  n_distinct = c(
    n_distinct(de$payee_city), 
    n_distinct(de$city_norm), 
    n_distinct(de$city_swap)
  ),
  prop_in = c(
    prop_in(de$payee_city, geo$city, na.rm = TRUE),
    prop_in(de$city_norm, geo$city, na.rm = TRUE),
    prop_in(de$city_swap, geo$city, na.rm = TRUE)
  ),
  unique_bad = c(
    length(setdiff(de$payee_city, geo$city)),
    length(setdiff(de$city_norm, geo$city)),
    length(setdiff(de$city_swap, geo$city))
  )
)
```

## Conclude

1. There are `r nrow(de)` records in the database.
1. There are `r sum(de$dupe_flag)` duplicate records in the database.
1. The range and distribution of `amount` and `expenditure_date` seem reasonable.
1. There are `sum(mi$na_flag)` records missing either recipient or date.
1. Consistency in goegraphic data has been improved with `campfin::normal_*()`.
1. The 5-digit `zip_norm` variable has been created with `campfin::normal_zip()`.
1. The 4-digit `expenditure_year` variable has been created with `lubridate::year()`.

## Export
 
```{r proc_dir}
proc_dir <- here("de", "expends", "data", "processed")
dir_create(proc_dir)
```
 
```{r write_clean}
write_csv(
  x = de,
  na = "na",
  path = glue("{proc_dir}/de_expends_clean.csv")
)
```

