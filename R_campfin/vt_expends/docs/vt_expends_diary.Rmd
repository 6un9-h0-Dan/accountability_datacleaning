---
title: "Data Diary"
subtitle: "Vermont Expenditures"
author: "Kiernan Nicholls"
date: "`r format(Sys.time())`"
output:
  html_document: 
    df_print: tibble
    fig_caption: yes
    highlight: tango
    keep_md: yes
    max.print: 32
    toc: yes
    toc_float: no
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, purl=FALSE}
library(knitr)
opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  comment = "#>",
  fig.path = "../plots/",
  fig.width = 10,
  dpi = 300
)
options(width = 99)
```

## Objectives

1. How many records are in the database?
1. Check for duplicates
1. Check ranges
1. Is there anything blank or missing?
1. Check for consistency issues
1. Create a five-digit ZIP Code called ZIP5
1. Create a YEAR field from the transaction date
1. For campaign donation data, make sure there is both a donor AND recipient

## Packages

The following packages are needed to collect, manipulate, visualize, analyze, and communicate
these results. The `pacman` package will facilitate their installation and attachment.

```{r p_load, message=FALSE, warning=FALSE, error=FALSE}
pacman::p_load(
  tidyverse, # data manipulation
  lubridate, # datetime strings
  magrittr, # pipe opperators
  janitor, # dataframe clean
  zipcode, # clean & databse
  batman, # parse yes & no
  refinr, # cluster & merge
  rvest, # scrape website
  knitr, # knit documents
  here, # locate storage
  fs # search storage 
)
```

```{r custom_funs_dat, echo=FALSE}
data("zipcode")
here <- here::here
"%out%" <- Negate("%in%")
print_all <- function(df) df %>% print(n = nrow(.)) 
```

This document should be run as part of the `R_campfin` project, which lives as a sub-directory
of the more general, language-agnostic `irworkshop/accountability_datacleaning` 
[GitHub repository](https://github.com/irworkshop/accountability_datacleaning).

The `R_campfin` project uses the 
[RStudio projects](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects)
feature and should be run as such. The project also uses the dynamic 
[`here::here()`](https://github.com/jennybc/here_here) tool for
file paths relative to _your_ machine.

```{r where_here, collapse=TRUE}
# where was this document knit?
here::here()
```

## Data

> Definition of Expenditure - 17 V.S.A. 2901(7)
> 
> Expenditure means a payment, disbursement, distribution, advance deposit, loan, or gift of money,
or anything of value paid or promised to be paid for the purpose of influencing an election,
advocating a position on a public question, or supporting or opposing one or more candidates. As
used in this chapter, expenditure shall not include any of the following:
> 
> 1. A personal loan of money to a candidate from a lending institution made in the ordinary course
> of business;
> 2. Services provided without compensation by individuals volunteering their time on behalf of a
> candidate, political committee, or political party;
> 3. Unreimbursed travel expenses paid for by an individual for himself or herself, who volunteers
> personal services to a candidate; or
> 4. Unreimbursed campaign-related travel expenses, paid for by the candidate or the candidates
> spouse.

## Read

```{r read_csv}
vt <- 
  here("vt_expends", "data", "raw", "ViewExpenditureList.csv") %>% 
  read_csv(
    col_types = cols(
      .default = col_character(),
      `Transaction Date` = col_date("%m/%d/%Y %H:%M:%S %p"),
      `Reporting Period` = col_date("%m/%d/%Y %H:%M:%S %p"),
      `Expenditure Amount` = col_number()
    )
  ) %>% 
  clean_names() %>% 
  remove_empty("rows") %>% 
  mutate_if(is.character, str_to_upper) %>% 
  rownames_to_column("id")
```

## Explore 

## Explore

There are `r nrow(vt)` records of `r length(vt)` variables in the full database.

```{r glimpse}
glimpse(sample_frac(vt))
```

### Distinct

The variables range in their degree of distinctness.

```{r n_distinct}
vt %>% 
  map(n_distinct) %>% 
  unlist() %>% 
  enframe(name = "variable", value = "n_distinct") %>% 
  mutate(prop_distinct = round(n_distinct / nrow(vt), 4)) %>%
  print(n = length(vt))
```

We can use `ggplot2::geom_bar()` to explore the distribution of these least distinct nominal
values.

```{r plot_payee_type, echo=FALSE, fig.height=10}
ggplot(vt) + 
  geom_bar(aes(payee_type)) + 
  coord_flip() +
  labs(title = "VT Payee Type")
```

```{r plot_reg_type, echo=FALSE, fig.height=10}
ggplot(vt) + 
  geom_bar(aes(registrant_type)) + 
  coord_flip() +
  labs(title = "VT Registrant Type")
```

```{r plot_office, echo=FALSE, fig.height=10}
vt$office %>% 
  str_extract("(?:(?!-).)*") %>% 
  str_trim() %>% 
  enframe(NULL) %>%
  ggplot() +
  geom_bar(aes(value)) +
  coord_flip() +
  labs(title = "VT Office")
```

```{r plot_cycle, echo=FALSE, fig.height=10}
ggplot(vt) + 
  geom_bar(aes(election_cycle)) + 
  coord_flip() +
  labs(title = "VT Election Cycle")
```

```{r plot_expend_type, echo=FALSE}
ggplot(vt) + 
  geom_bar(aes(expenditure_type)) +
  labs(title = "VT Expenditure Type (Log)") +
  scale_y_log10()
```

```{r plot_expend_amt_type, echo=FALSE}
vt %>% 
  filter(!is.na(expenditure_type)) %>% 
  ggplot() +
  scale_y_continuous(labels = scales::dollar, trans = "log10") +
  labs(title = "VT Expenditure Amount by Type (Log)") +
  geom_boxplot(
    mapping = aes(
      x = expenditure_type,
      y = expenditure_amount
    )
  )
```

### Duplicate

We can use `janitor::get_dupes()` to create a new table of records with duplicate values across
all rows. We will flag these with a new `dupe_flag` variable and join them back to the original
data.

```{r get_dupes}
vt_dupes <- vt %>% 
  select(-id) %>% 
  get_dupes() %>% 
  select(-dupe_count) %>% 
  mutate(dupe_flag = TRUE) %>% 
  distinct()

vt <- vt %>% 
  left_join(vt_dupes) %>% 
  mutate(dupe_flag = !is.na(dupe_flag))
```

### Missing

The variables also vary in their degree of values that are `NA` (missing). Note that 68 rows were
removed using `janitor::remove_empty()` during our initial reading of the file. The remaining count
of missing values in each variable can be found below:

```{r count_na}
vt %>% 
  map(function(var) sum(is.na(var))) %>% 
  unlist() %>% 
  enframe(name = "variable", value = "n_na") %>% 
  mutate(prop_na = n_na / nrow(vt)) %>% 
  print(n = length(vt))
```

Most variables have zero `NA` values, aside from the supplemental `public_question` and `comments` 
variables. `NA` values in the `office` variable represent expenditures from non-candidate
registrants.

```{r office_na}
vt %>% 
  group_by(registrant_type) %>% 
  summarise(n_na = sum(is.na(office)))
```

### Ranges

The range of continuous variables will need to be checked for data integrity. There are only three
quasi-continuous variables, the `transaction_date`, `reporting_period`, and `expenditure_amount`.

The range for `trans_amount` seems reasonable enough.

```{r tran_amount_range}
summary(vt$expenditure_amount)
```

```{r plot_exp_amt_type, echo=FALSE}
vt %>% 
  ggplot(mapping = aes(expenditure_amount)) +
  geom_histogram() +
  scale_x_continuous(trans = "log10", labels = scales::dollar) +
  facet_wrap(~expenditure_type, scales = "free_y") +
  labs(
    title = "Distribution of VT Expenditures",
    x = "Expenditure Amount (USD)",
    y = "Number of Expenditures"
  )
```

The number of contributions is fairly lopsides, with nearly 80% of all records coming from 2016 and
2018. This makes some sense, as these were election years.

```{r tran_date_range}
summary(vt$transaction_date)
```

```{r plot_exp_year}
vt %>% 
  group_by(transaction_year = year(transaction_date)) %>% 
  ggplot(mapping = aes(transaction_year)) +
  geom_bar() +
  scale_x_continuous(breaks = seq(2007, 2020)) + 
  labs(
    title = "Number of Expenditures by Year",
    x = "Year",
    y = "Number of Expenditures"
  )
```

For some reason, the reporting period for expenditures begin in 2014 despite our data spanning
2008 to 2019.

```{r rep_per_range}
summary(vt$reporting_period)
```

## Mutate

Payee and registrant addresses are not divided into street, city, state, and ZIP columns. We can
extract the ZIP digits and state abbreviation from the end of the string using regular expressions.

Since we parsed the `transaction_date` as a date file using `readr::col_date()` inside
`readr::read_csv()`, we can simply extract the year of the transaction with `lubridate::year()`

```{r add_zip}
vt <- vt %>% 
  mutate(
    payee_zip = payee_address %>% 
      str_extract("[\\d-]+$") %>% 
      clean.zipcodes(),
    payee_state = payee_address %>% 
      str_remove("[\\d-]+$") %>% 
      str_trim() %>% 
      str_extract("..$"),
    transaction_year = year(transaction_date)
    )
```

## Clean

There are `r length(vt$payee_address[which(vt$payee_state %out% zipcode$state)])` records
with invalid `payee_state` values. Aside from those that are "US" (which should be "VT"),
the rest can be made `NA`, as they represent expenditures made overseas.

```{r fix_state}
unique(vt$payee_address[which(vt$payee_state %out% zipcode$state)])
vt$payee_state[which(vt$payee_state == "US")] <- "VT"
vt$payee_state[which(vt$payee_state %out% zipcode$state)] <- NA
```

All zipcodes are five digits, but there are a handful that do not exist in our list of valid
zipcodes. We can remove those we know to be truly invalid, but leave the rest.

```{r check_zip, collapse=TRUE}
vt$payee_zip[which(nchar(vt$payee_zip) != 5)]
unique(vt$payee_zip[vt$payee_zip %out% zipcode$zip])
```

```{r fix_zip}
vt$payee_zip <- vt$payee_zip %>% 
  na_if("00000") %>% 
  na_if("11111") %>% 
  na_if("33333")

vt %>%
  filter(!is.na(payee_zip)) %>%
  filter(payee_zip %out% zipcode$zip) %>% 
  select(
    payee_name,
    payee_address,
    payee_zip,
    payee_state
  ) %>% 
  distinct() %>% 
  arrange(payee_state) %>% 
  print_all()
```

## Conclude

1. There are `r nrow(vt)` records in the database
1. The `r sum(vt$dupe_flag)` duplicate records have been flagged with `dupe_flag`
1. Ranges for continuous variables have been checked and make sense
1. There are no important variables with blank or missing values
1. Consistency issues have been fixed with the `stringr` package
1. The `payee_zip` variable has been extracted from `payee_address` with `stringr::str_extract()`
and cleaned with `zipcode::clean.zipcode()`
1. The `transaction_year` variable has been extracted from `transaction_date` with
`readr::col_date()` and `lubridate::year()`
1. There is both a registrant and payee for every record.

## Write

```{r write_csv}
dir_create(here("vt_expends", "data", "processed"))
write_csv(
  x = vt,
  path = here("vt_expends", "data", "processed", "vt_expends_clean.csv"),
  na = ""
)
```

