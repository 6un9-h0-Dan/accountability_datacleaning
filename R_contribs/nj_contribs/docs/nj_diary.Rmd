---
title: "Data Diary"
subtitle: "New Jersey Contributions"
author: "Kiernan Nicholls"
date: "`r format(Sys.time())`"
output:
  html_document: 
    df_print: tibble
    fig_caption: yes
    highlight: tango
    keep_md: yes
    max.print: 32
    toc: yes
    toc_float: no
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  error = FALSE
)
options(width = 99)
```

## Objectives

1. How many records are in the database?
1. Check for duplicates
1. Check ranges
1. Is there anything blank or missing?
1. Check for consistency issues
1. Create a five-digit ZIP Code called ZIP5
1. Create a YEAR field from the transaction date
1. For campaign donation data, make sure there is both a donor AND recipient

## Packages

```{r pkgs, message=FALSE, warning=FALSE, error=FALSE}
# install.packages("pacman")
pacman::p_load(
  tidyverse,
  RSelenium,
  lubridate,
  magrittr,
  janitor,
  zipcode,
  vroom,
  rvest,
  here,
  fs
)
```

## Data

Data comes courtesy of the New Jersey Election Law Enforcement Commission (ELEC)
[website](https://www.elec.state.nj.us/ELECReport/). The data can be downloaded from their 
["Quick Data Downloads"](https://www.elec.state.nj.us/publicinformation/quickdownload.htm) page in
four separate files:

* [`All_GUB_Text.zip`]("https://www.elec.state.nj.us/download/Data/Gubernatorial/All_GUB_Text.zip")
* [`All_LEG_Text.zip`]("https://www.elec.state.nj.us/download/Data/Legislative/All_LEG_Text.zip")
* [`All_CW_Text.zip`]("https://www.elec.state.nj.us/download/Data/Countywide/All_CW_Text.zip")
* [`All_PAC_Text.zip`]("https://www.elec.state.nj.us/download/Data/PAC/All_PAC_Text.zip")

Each ZIP file contains a number of individual TXT files separated by year.

ELEC makes the following disclaimer at the bottom of the download page:

> The data contained in the ELEC database includes information as reported by candidates and
committees. Although ELEC has taken all reasonable precautions to prevent data entry errors, the
possibility that some exist cannot be entirely eliminated. Contributor and Expenditure types are
coded by ELEC staff members and are subjective according to the information provided by the filer.
Additionally, this information is subject to change as amendments are filed by candidates and
committees. For the most up-to-date information, please go to the “Search for Contributions” pages
to search for the most recent contributor information.

## Read

The files can be read into R after downloading and unzipping. The delimiter used in each file is inconsistent, with some using tabs and others using commas. The `vroom::vroom()` function will
allow us to read all the unzipped files (~100) at once, with automatic detection of the delimeter.

First, download each file and unzip each into the `nj_contribs/data` directory.

```{r download_files}
# list all files
nj_zip_files <- c(
  "https://www.elec.state.nj.us/download/Data/Gubernatorial/All_GUB_Text.zip", # (5.7 MB)
  "https://www.elec.state.nj.us/download/Data/Legislative/All_LEG_Text.zip", # (9.7 MB)
  "https://www.elec.state.nj.us/download/Data/Countywide/All_CW_Text.zip", # (3.5 MB)
  "https://www.elec.state.nj.us/download/Data/PAC/All_PAC_Text.zip" # (6.2 MB)
)

# create a direcory for download
dir.create(here("nj_contribs", "data"))

# download each file in the list
# 
for (file in nj_zip_files) {
  download.file(
    url = file,
    destfile = here(
      "nj_contribs",
      "data",
      basename(file)
    )
  )
}

# unzip each file downloaded
here("nj_contribs", "data") %>%
  dir_ls(type = "file", glob = "*.zip") %>%
  map(
    unzip,
    exdir = here("nj_contribs", "data"),
    overwrite = TRUE
  )
```

While every file has the same structure, the _names_ of those columns vary slightly. In some, there
is an `occupation` variable; in others, that variable is named `occupation_name`. This incongruity
prevents them from all being read together with `vroom::vroom()`. We can solve this by extracting
the variable names from a single file and using those to names for every file.

```{r}
# extract names from first file
nj_names <-
  here("nj_contribs", "data") %>%
  dir_ls(type = "file", glob = "*.txt") %>%
  extract(1) %>%
  read.table(sep = "\t", nrows = 1, header = FALSE) %>%
  as_vector() %>%
  str_to_lower()
```

One we have this vector of column names, we can read each file into a single data fram. Every
column will be read as character strings and parsed after the fact using the `dplyr::parse_*()`
functions. Normally we would use `col_types = cols(cont_date = col_date())`, but this seems to
introduce a number of `NA` values from some unknown parsing error that is does not happen with
`dplyr::parse_date()`.

```{r}
nj <-
  here("nj_contribs", "data") %>%
  dir_ls(type = "file", glob = "*.txt") %>%
  vroom(
    delim = NULL,
    col_names = nj_names,
    col_types = cols(.default = "c"),
    id = "source",
    skip = 1,
    trim_ws = TRUE,
    locale = locale(tz = "US/Eastern"),
    progress = FALSE
  ) %>%
  mutate(
    source    = basename(source),
    cont_date = parse_date(cont_date, "%m/%d/%Y"),
    cont_amt  = parse_number(cont_amt)
  )
```

## Explore

Below is the structure of the data arranged randomly by row. There are `r nrow(nj)` rows of 
`r length(nj)` variables.

```{r glimpse_all}
glimpse(sample_frac(nj))
```

The hard files contain data on elections from `r min(nj$election_year)` to `r
max(nj$election_year)`. When you filter out those contributions made before 2008, about
$\frac{2}{3}$ of the data is remove.

```{r filter_date}
nj <- nj %>% filter(cont_date > "2008-01-01")
nrow(nj)
min(nj$cont_date)
max(nj$cont_date)
```

There are `r nrow(nj)-nrow(distinct(nj))` rows with duplicates values in every variable. Over 1% of
rows are complete duplicates.

```{r n_distinct}
nrow(distinct(nj)) - nrow(nj)
```

### Distinct

The variables vary in their degree of distinctiveness.

```{r count_distinct}
nj %>% 
  map(n_distinct) %>% 
  unlist() %>% 
  enframe(name = "variable", value = "n_distinct") %>% 
  mutate(prop_distinct = round(n_distinct / nrow(nj), 4)) %>%
  print(n = length(nj))
```

For the least distinct variables, we can explore the most common values.

```{r tabyls}
nj %>% tabyl(source) %>% arrange(desc(n))
nj %>% tabyl(party) %>% arrange(desc(n))
nj %>% tabyl(election_year)
nj %>% tabyl(election_type) %>% arrange(desc(n))
nj %>% tabyl(cont_type) %>% arrange(desc(n))
nj %>% tabyl(receipt_type) %>% arrange(desc(n))
nj %>% tabyl(office) %>% arrange(desc(n))
nj %>% tabyl(cont_state) %>% arrange(desc(n))
nj %>% tabyl(occupation) %>% arrange(desc(n))
```

### Duplicates

There are nearly 1,300 records with values across every variable duplicated at least once more.

```{r get_dupes}
# create dupes df
nj_dupes <- nj %>% 
  get_dupes() %>%
  distinct() %>% 
  mutate(dupe_flag = TRUE)

# show dupes
nj_dupes %>% 
  mutate(rec = coalesce(rec_lname, rec_non_ind_name)) %>% 
  select(
    cont_lname,
    cont_amt,
    cont_date,
    rec,
    dupe_count
  ) %>% 
  print()
```

Flag these duplicate rows by joining the duplicate table with the original data.

```{r}
nj <- left_join(nj, nj_dupes)
```

Since there is no entirely unique variable to track contributions, we will create one.

```{r rownames_to_column, collapse=TRUE}
nj <- nj %>%
  # unique row num id
  rownames_to_column(var = "id") %>% 
  # make all same width
  mutate(id = str_pad(
    string = id, 
    width = max(nchar(id)), 
    side = "left", 
    pad = "0")
  )

n_distinct(nj$id) == nrow(nj)
```

### `NA`

```{r count_na}
nj %>% map(function(var) sum(is.na(var))) %>% 
  unlist() %>% 
  enframe(name = "variable", value = "n_na") %>% 
  mutate(prop_na = n_na / nrow(nj)) %>% 
  print(n = length(nj))
```

## Clean

New variables will be added with _cleaned_ versions of the original data. Cleaning follows the
[IRW data cleaning guide](https://github.com/irworkshop/accountability_datacleaning/blob/master/R_contribs/accountability_datacleaning/IRW_guides/data_check_guide.md). Cleaned variables will all
match the `*_clean` name syntax.

This primarily means correcting obvious spelling and structure mistakes in Address, City, State,
and ZIP variables. Steps will also be taken to remove punctuation and make strings consistently
uppercase. New variables will also be made from the original data to match the searching parameters
of the Accountability Project database. Rows with unresolvable errors in `*_clean` will be flagged
with a logical `*_flag` variable.

Ultimately, each cleaned variable should contain less distinct values. This would indicate typos
have been corrected and invalid values made `NA`.

### Year

Since the `cont_date` variable was parsed as an R date object through `readr::read_delim()`, the
`lubridate::year()` function makes this step easy.

```{r mutate_year}
# extract year variable
nj <- nj %>% mutate(year = year(cont_date))
```

There are a number of year variables that don't make any sense. Since we previously filtered any
date before 2008-01-01, the only erroneous dates are from the future. There are 11 records with
date values from the future. They can be flagged with a new `date_flag` variable.

```{r}
# print all years
sort(unique(nj$year))

# view futures contribs
nj %>% 
  filter(cont_date > today()) %>% 
  arrange(cont_date) %>% 
  mutate(cont = coalesce(cont_lname, cont_non_ind_name)) %>% 
  mutate(rec = coalesce(rec_lname, rec_non_ind_name)) %>% 
  select(cont_date, cont, cont_amt, rec, source) %>% 
  print()

# flag future contribs
nj <- nj %>% mutate(date_flag = cont_date > today())
```

### ZIPs

The `zipcodes::clean.zipcodes()` function automates many of the required steps to clean US Zip code
strings. From the function documentation:

> Attempts to detect and clean up suspected ZIP codes. Will strip "ZIP+4" suffixes to match format
of zipcode data.frame. Restores leading zeros, converts invalid entries to NAs, and returns
character vector. Note that this function does not attempt to find a matching ZIP code in the
database, but rather examines formatting alone.

The `zipcode` package also contains a useful `zipcode` database: 

> This package contains a database of city, state, latitude, and longitude information for U.S. ZIP
codes from the CivicSpace Database (August 2004) and augmented by Daniel Coven's
federalgovernmentzipcodes.us web site (updated January 22, 2012).

```{r}
data("zipcode")

zipcode <- zipcode %>% 
  as_tibble() %>% 
  select(city, state, zip) %>% 
  mutate(city = str_to_upper(city))

zipcode %>% sample_n(10)
```

```{r mutate_zip5, collapse=TRUE}
nj <- nj %>% mutate(zip5 = clean.zipcodes(cont_zip))

nj$zip5 <- nj$zip5 %>% 
  na_if("0") %>% 
  na_if("000000") %>% 
  na_if("999999")

n_distinct(nj$cont_zip)
n_distinct(nj$zip5)
```

We can filter for zip codes that are not five characters long and compare them against the first valid zipcode for that contributor's city and state. If need be, the `cont_street1` can be looked
up to get an exact ZIP.

```{r}
nj_bad_zip <- nj %>% 
  filter(nchar(zip5) != 5) %>% 
  select(id, cont_street1, cont_city, cont_state, cont_zip, zip5) %>% 
  left_join(zipcode, by = c("cont_city" = "city", "cont_state" = "state")) %>% 
  group_by(cont_city, cont_state) %>% 
  slice(1) %>% 
  rename(clean_zip = zip5, valid_zip = zip)

print(nj_bad_zip)
```

Then some of these typo ZIPs can be corrected explicitly using their unique `id`. Most either
contain an erroneous leading zero or trailing digit.

```{r zip_fix_manual, collapse=TRUE}
nj$zip5[nj$id == "078916"] <- "08816" # valid NJ
nj$zip5[nj$id == "179554"] <- "83713" # valid boise
nj$zip5[nj$id == "082309"] <- "08302" # valid bridgeton
nj$zip5[nj$id == "137753"] <- "08077" # valid cinnaminson
nj$zip5[nj$id == "187741"] <- "07932" # valid florham
nj$zip5[nj$id == "188589"] <- NA      # can't say
nj$zip5[nj$id == "139227"] <- "08691" # valid hamilton
nj$zip5[nj$id == "258254"] <- NA      # can't say
nj$zip5[nj$id == "165661"] <- "10013" # valid nyc
nj$zip5[nj$id == "238983"] <- "08902" # valid n brunswick
nj$zip5[nj$id == "261083"] <- "08902" # valid n brunswick
nj$zip5[nj$id == "259238"] <- "84201" # valid ogden
nj$zip5[nj$id == "098051"] <- "63105" # valid stl
nj$zip5[nj$id == "146304"] <- "08872" # valid sayreville
nj$zip5[nj$id == "253099"] <- "07666" # valid teaneck
nj$zip5[nj$id == "038095"] <- "07083" # valid union
n_distinct(nj$zip5)
sum(nchar(nj$zip5) != 5, na.rm = TRUE)
```

### States

We can clean states abbreviations by comparing the `cont_state` variable values against a
comprehensive list of valid abbreviations.

The `zipcode` database also contains many city names and the full list of abbreviations for all US
states, territories, and military mail codes (as opposed to `datasets::state.abb`).

I will add rows for the Canadian provinces from Wikipedia. The capital city and largest city are
included alongside the proper provincial abbreviation. Canada uses a different ZIP code convention,
so that data cannot be included.

```{r can_zips, collapse=TRUE}
canadian_zips <-
  # read in page source code
  read_html("https://en.Wikipedia.org/wiki/Provinces_and_territories_of_Canada") %>%
  # select the table node
  html_node("table.wikitable:nth-child(12)") %>% 
  # read as data frame
  html_table(fill = TRUE) %>% 
  # clean name and format
  as_tibble(.name_repair = make_clean_names) %>% 
  # remove top and bottom
  slice(-1, -nrow(.)) %>% 
  # remove extra rows
  select(postalabbrev, capital_1, largestcity_2) %>%
  rename(state = postalabbrev,
         capital = capital_1, 
         queen = largestcity_2) %>% 
  # gather city names
  gather(-state, capital, queen,
         key = type,
         value = city) %>% 
  select(-type) %>% 
  # keep one if capital == queen
  distinct()
```

We can use this database to locate records with invalid values and compare them against possible
valid values. Here, we can see most invalid `cont_state` values are reasonable typos that can be
corrected.

```{r valid_abb}
zipcode <- zipcode %>% 
  bind_rows(canadian_zips) %>%
  mutate(city = str_to_upper(city))

valid_abb <- sort(unique(zipcode$state))
setdiff(valid_abb, state.abb)
```

```{r clean_state, collapse=TRUE}
sum(!(na.omit(nj$cont_state) %in% valid_abb))
n_distinct(nj$cont_state)

nj %>% 
  filter(!(cont_state %in% valid_abb)) %>% 
  select(id, cont_city, cont_state, cont_zip) %>% 
  filter(!is.na(cont_state)) %>% 
  left_join(
    y = zipcode %>% select(zip, city, state), 
    by = c("cont_zip" = "zip")
  )

nj$state_clean <- nj$cont_state %>% 
  str_replace_all(pattern = "MJ", replacement = "NJ") %>% 
  str_replace_all("^N$",  "NJ") %>% 
  str_replace_all("NK", "NJ") %>% 
  str_replace_all("TE", "TN") %>% 
  str_replace_all("^P$",  "PA") %>% 
  str_replace_all("^7$",  "PA")

sum(!(na.omit(nj$state_clean) %in% valid_abb))
n_distinct(nj$state_clean)
```

```{r tabyl_state}
nj %>% 
  tabyl(state_clean) %>% 
  arrange(desc(n)) %>% 
  as_tibble() %>% 
  mutate(cum_percent = cumsum(percent))
```

### Cities

The State of New Jersey publishes a comprehensive list of all municipalities in the state. We can
read that file from the internet to check the `cont_city` variable values.

Not all conributions come from New Jersey, but 9/10 do so this list is a good start.

```{r}
nj_muni <- 
  read_tsv(
    file = "https://www.nj.gov/infobank/muni.dat", 
    col_names = c("muni", "county", "old_code", "tax_code", "district", "fed_code", "county_code"),
    col_types = cols(.default = col_character())
  ) %>% 
  # remove muni type suffix
  mutate(county = str_to_upper(county),
         muni = muni %>% 
           str_to_upper() %>% 
           str_remove_all("\\sTWP.$") %>% 
           str_remove_all("\\sBORO$") %>% 
           str_remove_all("\\sCITY$")
  )

valid_muni <- sort(unique(nj_muni$muni))
```

With this list and the fairly comprehensive list of cities from other states, we can isolate only
the most suspicious `cont_city` values.

```{r}
n_distinct(nj$cont_city)

nj %>%
  filter(!(cont_city %in% c(valid_muni, zipcode$city))) %>% 
  filter(!is.na(cont_city)) %>% 
  group_by(cont_city) %>% 
  count() %>% 
  arrange(desc(n))
```

## Write

```{r write_csv, eval=FALSE}
nj %>% 
  # remove unclean cols
  select(
    -cont_state,
    -cont_zip
  ) %>% 
  # write to disk
  write_csv(
    path = here("nj_contribs", "data", "nj_contribs_clean.csv"),
    na = ""
  )
```

